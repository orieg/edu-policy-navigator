# Chat Widget Implementation Plan

**Goal:** Implement a small, expandable chat widget that integrates with the in-browser KuzuDB/WebLLM RAG backend to provide policy information for a selected school district, drawing insights from best practices like those detailed at [KuzuDB Blog: In-Browser Graph RAG](https://blog.kuzudb.com/post/kuzu-wasm-rag/).

**Assumptions:**
*   Core KuzuDB/WebLLM handlers (`kuzudbHandler.ts`, `webllmHandler.ts`), the `ragController.ts` (which implements the 3-step Graph RAG: Text-to-Cypher, Cypher-to-Context, Context-to-Answer), and state management for `currentDistrictId`, KuzuDB instances, and the WebLLM engine are implemented or planned as per `IMPLEMENTATION.md` (Phase 4.3). The `ragController` is expected to handle schema inclusion in prompts for Text-to-Cypher.
*   **KuzuDB Data Loading:** Unlike the dynamic CSV ingestion shown in the referenced KuzuDB blog post, this project utilizes **pre-built KuzuDB database files (`.db`)** for each district, generated by the backend data pipeline (see `IMPLEMENTATION.md`, Phase 2.6). The `kuzudbHandler.ts` is responsible for loading the appropriate pre-built `.db` file for the selected district into KuzuDB-Wasm on the client-side. Files like `public/assets/districts.json` are used for UI population (e.g., district selectors) and to identify which pre-built database to load, not for direct client-side ingestion into KuzuDB to build the graph.
*   A testing script is available via `pnpm run test`.

**Guidance:**
 * When not sure of current implementation, review code in `src/`.
 * Never assume blindly, always confirm current implementation before changing or adding new code.
 * Do not add new framework unless explicitly asked for it.
 * Use our global CSS and shared color palette.

---

**Progress Log / Current Status:**

*   **Initial Setup & Planning:** Established plan, created this file.
*   **Widget UI (`ExpandableChatWidget.astro`, `ChatWindow.astro`):**
    *   Created components, integrated into `BaseLayout.astro`.
    *   Styled using plain CSS and global variables.
    *   Implemented expand/collapse, parent-child communication (custom events, exposed methods).
    *   Ensured `ChatWindow.astro` handles various message types and can control input state.
    *   Troubleshot styling, JS syntax, and communication issues.
*   **RAG Backend Handlers (Phase 2.5 initiated):**
    *   **`kuzudbHandler.ts` (Task 6 - In Progress/Largely Complete):**
        *   Created `src/lib/kuzudbHandler.ts`, installed `kuzu-wasm`.
        *   Configured `vite-plugin-static-copy` for worker script.
        *   Implemented handler class, refined API usage.
        *   Created `src/kuzu-wasm.d.ts` for basic types.
        *   Integrated `initialize()` into `ExpandableChatWidget.astro`, confirmed working.
    *   **`webllmHandler.ts` (Task 7 - In Progress/Largely Complete):**
        *   Created `src/lib/webllmHandler.ts`, installed `@mlc-ai/web-llm`.
        *   Refactored based on `MLCEngine` and `engine.chat.completions.create` API.
    *   Moved WebLLM model ID to `src/siteConfig.ts`.
    *   `ExpandableChatWidget.astro` initializes both handlers.
*   **`ragController.ts` (Task 8 - In Progress):**
    *   Created `src/lib/ragController.ts` with a basic structure: constructor, `processQuery` method, and private placeholder methods (`_textToCypher`, `_cypherToContext`, `_contextToAnswer`).
    *   Integrated `RAGController` into `ExpandableChatWidget.astro`:
        *   Imported and instantiated `RAGController` during service initialization.
        *   Modified `handleQueryRequest` to call `ragController.processQuery()`.
        *   Updated `RAGController.processQuery` to return `Promise<void>` and send all messages (including final answer/error) via the `progressCallback`.
        *   The `progressCallback` in `RAGController` now accepts a `replaceLast?: boolean` argument, passed to `ChatWindow.astro`.
        *   Adjusted `ExpandableChatWidget.astro` to match the `void` return and pass `replaceLast` from the callback to `chatWindowWrapper.addMessage`.
    *   Verified that `ChatWindow.astro`'s `addMessage` method (exposed on `chatWindowWrapper`) already correctly handles a `replaceLast: boolean` parameter to replace the most recent message.

---

**Step-by-Step Implementation Tasks:**

**Phase 1: Core Component Setup & RAG Service Access Strategy**

1.  **[x] Task: Create `ExpandableChatWidget.astro` (Initial Shell)**
    *   **File:** `src/components/ExpandableChatWidget.astro`
    *   **Content:** Basic Astro component structure for the fixed widget container and the clickable toggle button.
    *   **Sub-task:** Determine and document strategy for `ExpandableChatWidget.astro` to access shared RAG state/services (e.g., `ragController`, `currentDistrictId`, instances of KuzuDB/WebLLM). This likely involves props from `BaseLayout.astro` or a global state store (`src/lib/state.ts`).
    *   **Testing:** Manually verify the basic widget toggle button renders.

2.  **[x] Task: Prepare `ChatWindow.astro` for RAG-Powered Embedding**
    *   **File:** `src/components/ChatWindow.astro`
    *   **Action:** Design, review, or refactor `ChatWindow.astro` to:
        *   Be cleanly embeddable within `ExpandableChatWidget.astro`.
        *   Accept necessary props for RAG functionality (e.g., `ragController` instance or specific methods, `currentDistrictId` or a reactive signal for it, initialized `kuzuDb` and `webLlmEngine` instances if passed directly) OR communicate via events.
        *   Define a clear `Props` interface (if props are used directly for RAG control).
        *   Internally manage and display UI states for: RAG backend loading/initializing (e.g., "Initializing AI...", "Loading district data..."), RAG backend ready, and errors from KuzuDB/WebLLM. **Crucially, design for potential performance variations of in-browser LLMs by providing clear, non-blocking loading indicators during the multi-step RAG process (Text-to-Cypher, DB query, Answer Generation).**
        *   Handle user input submission gracefully.
        *   Display user messages and AI responses, including visual cues for when the AI is processing.
    *   **Testing:** Unit/component tests for `ChatWindow.astro` focusing on prop handling and UI state rendering (including loading/error states for RAG) using mocked responses. (Mock interaction tested and working).

**Phase 2: Widget UI & Basic Interactivity**

3.  **[x] Task: Implement Expand/Collapse UI Logic for Widget Shell**
    *   **File:** `src/components/ExpandableChatWidget.astro`
    *   **Action:** Implement client-side script to toggle visibility of the expanded window area. Manage `aria-expanded` attributes.
    *   **Testing:** Manually test click-to-toggle functionality of the expanded view.

4.  **[x] Task: Style Collapsed & Expanded Widget Shell**
    *   **File:** `src/components/ExpandableChatWidget.astro`, `src/components/ChatWindow.astro` (using plain CSS with global variables)
    *   **Action:** Style the collapsed state (chat toggle button) and the expanded state (window frame, including `ChatWindow` content like header, messages, input area).
    *   **Testing:** Visually inspect styles and animations. Ensure use of global color palette. (Message bubble styling achieved).

5.  **[x] Task: Add Smooth Transitions for Expand/Collapse**
    *   **File:** `src/components/ExpandableChatWidget.astro` (CSS)
    *   **Action:** Implement CSS transitions for a smoother visual effect when the chat window opens and closes.
    *   **Testing:** Visually verify smooth opening and closing animations.

**Phase 2.5: RAG Backend Core Implementation**

6.  **[~] Task: Implement `kuzudbHandler.ts`** (Largely complete, core functionality for initialization and querying in place)
    *   **File:** `src/lib/kuzudbHandler.ts`
    *   **Action:**
        *   Develop logic for loading pre-built KuzuDB `.db` files for a selected district into KuzuDB-Wasm. (Current implementation initializes globally, district-specific DB loading path needs review/implementation if dynamic loading per district is required beyond initial setup).
        *   Implement KuzuDB instance management (initialization, connection, potentially disposal).
        *   Provide a method to execute Cypher queries against the loaded database and return results.
        *   Implement error handling for database loading, connection, and query execution.
    *   **Dependencies:** KuzuDB-Wasm library, district data manifest/lookup.
    *   **Testing:** Unit tests for loading specific district DBs, executing valid/invalid Cypher queries, and error handling. (Basic initialization tested via widget).

7.  **[~] Task: Implement `webllmHandler.ts`** (Core structure for initialization and response generation in place)
    *   **File:** `src/lib/webllmHandler.ts`
    *   **Action:**
        *   Develop logic for initializing the WebLLM engine (e.g., `MLCEngine` from WebLLM, model loading, progress reporting).
        *   Provide an interface to send prompts to the LLM and receive generated text responses (e.g., `generateResponse` method).
        *   Implement error handling for LLM initialization and prompt processing.
        *   Consider LLM instance management and resource handling (e.g., `dispose` methods if applicable).
    *   **Dependencies:** WebLLM library (`@mlc-ai/web-llm`).
    *   **Testing:** Unit tests for initializing the LLM, sending sample prompts, and handling potential LLM errors. (Initialization integrated, response generation placeholder in use by `ragController`).

8.  **[>] Task: Implement `ragController.ts`** (Structure in place, core logic for RAG steps needs implementation)
    *   **File:** `src/lib/ragController.ts`
    *   **Action:**
        *   Design and implement the `processQuery(query: string, progressCallback: Function)` method (or similar interface) to orchestrate the RAG pipeline. (Signature and basic flow established).
        *   **Step 1 (Text-to-Cypher):** Utilize `webllmHandler` to convert natural language `query` into a Cypher query. Ensure district-specific schema information is appropriately considered/included in the prompt. (**Next focus area**)
        *   **Step 2 (Cypher-to-Context):** Utilize `kuzudbHandler` to execute the generated Cypher query against the current district's KuzuDB instance and retrieve contextual information. (Placeholder in place, needs refinement based on actual KuzuDB results format).
        *   **Step 3 (Context-to-Answer):** Utilize `webllmHandler` to generate a natural language answer based on the original `query` and the retrieved `context`. (Placeholder in place, needs prompt engineering).
        *   Implement state management for the RAG process, using `progressCallback` to report different processing stages, success, and errors. (Basic callback mechanism implemented).
        *   Handle initialization of `kuzudbHandler` and `webllmHandler` (done by `ExpandableChatWidget.astro` before controller use).
    *   **Dependencies:** `kuzudbHandler.ts`, `webllmHandler.ts`.
    *   **Testing:** Unit/integration tests for the `processQuery` method, covering the full RAG flow with mocked handlers. Test different query types, successful outcomes, and various error conditions in each RAG step. (Current testing relies on widget integration with placeholder methods).

**Phase 3: RAG Integration & Full `ChatWindow.astro` Functionality**

9.  **[x] Task: Embed RAG-Ready `ChatWindow.astro` & Pass Dependencies/Setup Events**
    *   **File:** `src/components/ExpandableChatWidget.astro`
    *   **Action:** Import and embed the prepared `ChatWindow.astro`. Establish communication (e.g., event listeners for queries, methods for responses) for RAG interactions, now with the `ragController` in mind.
    *   **Testing:** Verify `ChatWindow.astro` renders correctly and mock communication flow works.

10. **[~] Task: Implement Core Chat Logic via `ragController`** (Partially done; `ExpandableChatWidget` calls `ragController`, which uses placeholders)
    *   **File:** `src/components/ExpandableChatWidget.astro` (handler for chat events).
    *   **Action:**
        *   Replace mock processing logic in `ExpandableChatWidget.astro` with calls to the `ragController.processQuery(...)`. (Done).
        *   Ensure `ChatWindow.astro` correctly displays AI responses and handles RAG processing states (loading, errors) based on feedback (e.g., callbacks) from `ragController`. (Mechanism in place).
        *   **Provide distinct visual feedback during the different stages of `ragController.processQuery` if possible (e.g., "Generating understanding...", "Searching policies...", "Composing answer...").** (Callback provides this, UI displays it).
        *   **Implement robust error handling and display user-friendly messages for failures during any RAG step (e.g., invalid Cypher generation, KuzuDB error, LLM answer generation failure).** (Error reporting through callback is in place).
    *   **Testing:** Test with the actual RAG pipeline. Verify message display, multi-stage feedback, and error states. (Currently testing with placeholder RAG steps).

11. **[ ] Task: Verify Dynamic RAG Backend Initialization and Context Switching**
    *   **Files:** Relevant layout/state files, `ExpandableChatWidget.astro`, `ChatWindow.astro`, RAG handlers.
    *   **Action:**
        *   Confirm KuzuDB/WebLLM initialization as per `IMPLEMENTATION.md`.
        *   Ensure correct, district-specific KuzuDB instance (and its schema for Text-to-Cypher via `ragController`) and WebLLM engine are used by `ChatWindow.astro`.
        *   Test chat functionality after changing districts to ensure RAG context updates.
    *   **Testing:** Manually switch districts; perform test queries. Monitor console/network. **Verify `ragController` uses the correct district schema implicitly by testing queries that depend on schema specifics.**

**Phase 4: Final Touches & System-Wide Testing**

12. **[x] Task: Integrate into Main Layout (if not already done for testing)**
    *   **File:** `src/layouts/BaseLayout.astro`
    *   **Action:** Ensure `<ExpandableChatWidget />` is correctly configured.
    *   **Testing:** Verify widget presence across site pages.

13. **[ ] Task: Ensure Responsiveness**
    *   **Files:** `ExpandableChatWidget.astro`, `ChatWindow.astro`, CSS.
    *   **Action:** Adjust styles for various screen sizes.
    *   **Testing:** Manual viewport testing. Automated UI tests if any.

14. **[ ] Task: Accessibility Review & Enhancements**
    *   **File:** `ExpandableChatWidget.astro`, `ChatWindow.astro`
    *   **Action:** Thorough keyboard navigation review, ARIA attributes, screen reader testing, color contrast.
    *   **Testing:** Manual keyboard/screen reader tests. Automated accessibility checks.

15. **[ ] Task: Full End-to-End RAG and UI Testing**
    *   **Action:** Comprehensive testing covering:
        *   District selection and correct RAG context/schema loading.
        *   Widget UI/UX (expand/collapse, animations, focus).
        *   **Query Complexity & Performance: Test with simple and complex natural language questions. Evaluate Cypher generation quality, answer relevance, and response times. Ensure UI handles delays gracefully.**
        *   **RAG Error Handling: Test scenarios where Text-to-Cypher might fail (ambiguous/complex queries), KuzuDB errors, or LLM answer generation issues.**
        *   UI behavior with long messages, multiple messages.
        *   Cross-browser compatibility.
    *   **Goal:** Ensure a robust, user-friendly, accessible, and functional chat widget with the RAG backend.

---

**Next Steps (Focus Areas):**

1.  **Implement `RAGController._textToCypher()`:** Use `WebLLMHandler` to convert natural language user queries into Cypher queries. This will involve prompt engineering and potentially passing KuzuDB schema information to the LLM.
2.  **Implement `RAGController._cypherToContext()`:** Refine how results from `KuzuDBHandler.query()` are processed into a string context suitable for the LLM. This depends on the actual structure of data in KuzuDB.
3.  **Implement `RAGController._contextToAnswer()`:** Refine the prompt engineering for generating the final answer using `WebLLMHandler` based on the original query and retrieved context.
4.  **District-Specific Data:** Address how `currentDistrictId` (if needed for KuzuDB path or schema variations) is actually obtained and utilized by the RAG services. The `kuzudbHandler` currently initializes globally.

---

**General Testing Guidance:**
*   Run `pnpm run test` frequently.
*   Complement with manual testing for UI, UX, and RAG functionality, especially considering in-browser LLM performance variations.
*   Use browser developer tools extensively.

---

**Phase X: Potential Enhancements & Long-Term Considerations (Post-MVP)**

*   **State Management Reactivity (Astro Specific):**
    *   If using a global state store (e.g., `src/lib/state.ts`), thoroughly review and test how Astro components (`ExpandableChatWidget.astro`, `ChatWindow.astro`) subscribe to and react to changes in shared state (e.g., `currentDistrictId`, RAG service readiness, KuzuDB/WebLLM instances). Given Astro's island architecture, ensure client-side scripts handle external state updates correctly to re-render or update behavior as needed.

*   **User Input Sanitization:**
    *   While Astro provides some XSS protection by default, if user messages are ever directly rendered as HTML (e.g., if future features allow markdown or rich text from users), ensure robust input sanitization is implemented to prevent XSS vulnerabilities.

*   **Chat History Management (UX):**
    *   Consider adding a client-side feature to allow users to clear the current session's chat history within the `ChatWindow.astro` component. (Note: PRD specifies no saving history across browser sessions).

*   **Resource Management for KuzuDB/WebLLM Instances:**
    *   Investigate and confirm if explicit cleanup or disposal operations are needed for KuzuDB instances or the WebLLM engine when the chat widget is closed for a long time, the user navigates to a completely different section of the site, or the browser tab is closed. This might involve adding `dispose()` methods to `kuzudbHandler.ts` and `webllmHandler.ts` to be called appropriately by the client-side logic managing these instances to free up browser memory and resources if they are not automatically reclaimed efficiently by the WebAssembly environment upon loss of reference.

*   **Scalability of Pre-built DBs & Manifest:**
    *   While primarily a backend pipeline concern (`IMPLEMENTATION.md`, Phase 2.6), monitor the total number and size of pre-built KuzuDB `.db` files and the `manifest.json`. If the number of districts grows exceptionally large, the size of `manifest.json` could impact initial load time or client-side processing. This might necessitate future optimizations in how the manifest is structured or loaded, potentially impacting the widget's data source lookup for the selected district.

*   **Advanced RAG UI Feedback:**
    *   Explore more granular UI feedback for the different stages of the RAG process (Text-to-Cypher, KuzuDB query execution, LLM answer synthesis) if the `ragController` can provide such state updates. This could enhance user perception of system activity during processing.

*   **Optimizing Perceived Performance for In-Browser LLMs:**
    *   Continuously evaluate strategies to improve the perceived performance of the in-browser LLM, such as progressive display of generated text (streaming), or optimizing prompts for faster Cypher generation and answer synthesis, as highlighted in the KuzuDB blog on in-browser RAG. 