# Chat Widget Implementation Plan

**Goal:** Implement a small, expandable chat widget that integrates with the in-browser KuzuDB/WebLLM RAG backend to provide policy information for a selected school district, drawing insights from best practices like those detailed at [KuzuDB Blog: In-Browser Graph RAG](https://blog.kuzudb.com/post/kuzu-wasm-rag/).

**Assumptions:**
*   Core KuzuDB/WebLLM handlers (`kuzudbHandler.ts`, `webllmHandler.ts`), the `ragController.ts` (which implements the 3-step Graph RAG: Text-to-Cypher, Cypher-to-Context, Context-to-Answer), and state management for `currentDistrictId`, KuzuDB instances, and the WebLLM engine are implemented or planned as per `IMPLEMENTATION.md` (Phase 4.3). The `ragController` is expected to handle schema inclusion in prompts for Text-to-Cypher.
*   **KuzuDB Data Loading:** Unlike the dynamic CSV ingestion shown in the referenced KuzuDB blog post, this project utilizes **pre-built KuzuDB database files (`.db`)** for each district, generated by the backend data pipeline (see `IMPLEMENTATION.md`, Phase 2.6). The `kuzudbHandler.ts` is responsible for loading the appropriate pre-built `.db` file for the selected district into KuzuDB-Wasm on the client-side. Files like `public/assets/districts.json` are used for UI population (e.g., district selectors) and to identify which pre-built database to load, not for direct client-side ingestion into KuzuDB to build the graph.
*   A testing script is available via `pnpm run test`.

**Guidance:**
 * When not sure of current implementation, review code in `src/`.
 * Never assume blindly, always confirm current implementation before changing or adding new code.
 * Do not add new framework unless explicitly asked for it.
 * Use our global CSS and shared color palette.

---

**Step-by-Step Implementation Tasks:**

**Phase 1: Core Component Setup & RAG Service Access Strategy**

1.  **[x] Task: Create `ExpandableChatWidget.astro` (Initial Shell)**
    *   **File:** `src/components/ExpandableChatWidget.astro`
    *   **Content:** Basic Astro component structure for the fixed widget container and the clickable toggle button.
    *   **Sub-task:** Determine and document strategy for `ExpandableChatWidget.astro` to access shared RAG state/services (e.g., `ragController`, `currentDistrictId`, instances of KuzuDB/WebLLM). This likely involves props from `BaseLayout.astro` or a global state store (`src/lib/state.ts`).
    *   **Testing:** Manually verify the basic widget toggle button renders.

2.  **[x] Task: Prepare `ChatWindow.astro` for RAG-Powered Embedding**
    *   **File:** `src/components/ChatWindow.astro`
    *   **Action:** Design, review, or refactor `ChatWindow.astro` to:
        *   Be cleanly embeddable within `ExpandableChatWidget.astro`.
        *   Accept necessary props for RAG functionality (e.g., `ragController` instance or specific methods, `currentDistrictId` or a reactive signal for it, initialized `kuzuDb` and `webLlmEngine` instances if passed directly) OR communicate via events.
        *   Define a clear `Props` interface (if props are used directly for RAG control).
        *   Internally manage and display UI states for: RAG backend loading/initializing (e.g., "Initializing AI...", "Loading district data..."), RAG backend ready, and errors from KuzuDB/WebLLM. **Crucially, design for potential performance variations of in-browser LLMs by providing clear, non-blocking loading indicators during the multi-step RAG process (Text-to-Cypher, DB query, Answer Generation).**
        *   Handle user input submission gracefully.
        *   Display user messages and AI responses, including visual cues for when the AI is processing.
    *   **Testing:** Unit/component tests for `ChatWindow.astro` focusing on prop handling and UI state rendering (including loading/error states for RAG) using mocked responses. (Mock interaction tested and working).

**Phase 2: Widget UI & Basic Interactivity**

3.  **[x] Task: Implement Expand/Collapse UI Logic for Widget Shell**
    *   **File:** `src/components/ExpandableChatWidget.astro`
    *   **Action:** Implement client-side script to toggle visibility of the expanded window area. Manage `aria-expanded` attributes.
    *   **Testing:** Manually test click-to-toggle functionality of the expanded view.

4.  **[x] Task: Style Collapsed & Expanded Widget Shell**
    *   **File:** `src/components/ExpandableChatWidget.astro`, `src/components/ChatWindow.astro` (using plain CSS with global variables)
    *   **Action:** Style the collapsed state (chat toggle button) and the expanded state (window frame, including `ChatWindow` content like header, messages, input area).
    *   **Testing:** Visually inspect styles and animations. Ensure use of global color palette. (Message bubble styling achieved).

5.  **[ ] Task: Add Smooth Transitions for Expand/Collapse**
    *   **File:** `src/components/ExpandableChatWidget.astro` (CSS)
    *   **Action:** Implement CSS transitions for a smoother visual effect when the chat window opens and closes.
    *   **Testing:** Visually verify smooth opening and closing animations.

**Phase 3: RAG Integration & Full `ChatWindow.astro` Functionality**

6.  **[x] Task: Embed RAG-Ready `ChatWindow.astro` & Pass Dependencies/Setup Events**
    *   **File:** `src/components/ExpandableChatWidget.astro`
    *   **Action:** Import and embed the prepared `ChatWindow.astro`. Establish communication (e.g., event listeners for queries, methods for responses) for RAG interactions.
    *   **Testing:** Verify `ChatWindow.astro` renders correctly and mock communication flow works.

7.  **[ ] Task: Implement Core Chat Logic via `ragController`**
    *   **File:** `src/components/ChatWindow.astro` (script section) and `src/components/ExpandableChatWidget.astro` (handler for chat events).
    *   **Action:**
        *   Replace mock processing logic in `ExpandableChatWidget.astro` with calls to the actual `ragController.processQuery(...)`.
        *   Ensure `ChatWindow.astro` correctly displays AI responses and handles RAG processing states (loading, errors) based on feedback from `ragController`.
        *   **Provide distinct visual feedback during the different stages of `ragController.processQuery` if possible (e.g., "Generating understanding...", "Searching policies...", "Composing answer...").**
        *   **Implement robust error handling and display user-friendly messages for failures during any RAG step (e.g., invalid Cypher generation, KuzuDB error, LLM answer generation failure).**
    *   **Testing:** Test with the actual RAG pipeline. Verify message display, multi-stage feedback, and error states.

8.  **[ ] Task: Verify Dynamic RAG Backend Initialization and Context Switching**
    *   **Files:** Relevant layout/state files, `ExpandableChatWidget.astro`, `ChatWindow.astro`, RAG handlers.
    *   **Action:**
        *   Confirm KuzuDB/WebLLM initialization as per `IMPLEMENTATION.md`.
        *   Ensure correct, district-specific KuzuDB instance (and its schema for Text-to-Cypher via `ragController`) and WebLLM engine are used by `ChatWindow.astro`.
        *   Test chat functionality after changing districts to ensure RAG context updates.
    *   **Testing:** Manually switch districts; perform test queries. Monitor console/network. **Verify `ragController` uses the correct district schema implicitly by testing queries that depend on schema specifics.**

**Phase 4: Final Touches & System-Wide Testing**

9.  **[x] Task: Integrate into Main Layout (if not already done for testing)**
    *   **File:** `src/layouts/BaseLayout.astro`
    *   **Action:** Ensure `<ExpandableChatWidget />` is correctly configured.
    *   **Testing:** Verify widget presence across site pages.

10. **[ ] Task: Ensure Responsiveness**
    *   **Files:** `ExpandableChatWidget.astro`, `ChatWindow.astro`, CSS.
    *   **Action:** Adjust styles for various screen sizes.
    *   **Testing:** Manual viewport testing. Automated UI tests if any.

11. **[ ] Task: Accessibility Review & Enhancements**
    *   **File:** `ExpandableChatWidget.astro`, `ChatWindow.astro`
    *   **Action:** Thorough keyboard navigation review, ARIA attributes, screen reader testing, color contrast.
    *   **Testing:** Manual keyboard/screen reader tests. Automated accessibility checks.

12. **[ ] Task: Full End-to-End RAG and UI Testing**
    *   **Action:** Comprehensive testing covering:
        *   District selection and correct RAG context/schema loading.
        *   Widget UI/UX (expand/collapse, animations, focus).
        *   **Query Complexity & Performance: Test with simple and complex natural language questions. Evaluate Cypher generation quality, answer relevance, and response times. Ensure UI handles delays gracefully.**
        *   **RAG Error Handling: Test scenarios where Text-to-Cypher might fail (ambiguous/complex queries), KuzuDB errors, or LLM answer generation issues.**
        *   UI behavior with long messages, multiple messages.
        *   Cross-browser compatibility.
    *   **Goal:** Ensure a robust, user-friendly, accessible, and functional chat widget with the RAG backend.

---

**General Testing Guidance:**
*   Run `pnpm run test` frequently.
*   Complement with manual testing for UI, UX, and RAG functionality, especially considering in-browser LLM performance variations.
*   Use browser developer tools extensively.

---

**Phase X: Potential Enhancements & Long-Term Considerations (Post-MVP)**

*   **State Management Reactivity (Astro Specific):**
    *   If using a global state store (e.g., `src/lib/state.ts`), thoroughly review and test how Astro components (`ExpandableChatWidget.astro`, `ChatWindow.astro`) subscribe to and react to changes in shared state (e.g., `currentDistrictId`, RAG service readiness, KuzuDB/WebLLM instances). Given Astro's island architecture, ensure client-side scripts handle external state updates correctly to re-render or update behavior as needed.

*   **User Input Sanitization:**
    *   While Astro provides some XSS protection by default, if user messages are ever directly rendered as HTML (e.g., if future features allow markdown or rich text from users), ensure robust input sanitization is implemented to prevent XSS vulnerabilities.

*   **Chat History Management (UX):**
    *   Consider adding a client-side feature to allow users to clear the current session's chat history within the `ChatWindow.astro` component. (Note: PRD specifies no saving history across browser sessions).

*   **Resource Management for KuzuDB/WebLLM Instances:**
    *   Investigate and confirm if explicit cleanup or disposal operations are needed for KuzuDB instances or the WebLLM engine when the chat widget is closed for a long time, the user navigates to a completely different section of the site, or the browser tab is closed. This might involve adding `dispose()` methods to `kuzudbHandler.ts` and `webllmHandler.ts` to be called appropriately by the client-side logic managing these instances to free up browser memory and resources if they are not automatically reclaimed efficiently by the WebAssembly environment upon loss of reference.

*   **Scalability of Pre-built DBs & Manifest:**
    *   While primarily a backend pipeline concern (`IMPLEMENTATION.md`, Phase 2.6), monitor the total number and size of pre-built KuzuDB `.db` files and the `manifest.json`. If the number of districts grows exceptionally large, the size of `manifest.json` could impact initial load time or client-side processing. This might necessitate future optimizations in how the manifest is structured or loaded, potentially impacting the widget's data source lookup for the selected district.

*   **Advanced RAG UI Feedback:**
    *   Explore more granular UI feedback for the different stages of the RAG process (Text-to-Cypher, KuzuDB query execution, LLM answer synthesis) if the `ragController` can provide such state updates. This could enhance user perception of system activity during processing.

*   **Optimizing Perceived Performance for In-Browser LLMs:**
    *   Continuously evaluate strategies to improve the perceived performance of the in-browser LLM, such as progressive display of generated text (streaming), or optimizing prompts for faster Cypher generation and answer synthesis, as highlighted in the KuzuDB blog on in-browser RAG. 