---
// src/components/ExpandableChatWidget.astro
// This component will manage the collapsed and expanded state of the chat widget.

// Props will be defined here later if needed, e.g., to pass district info or handlers.
interface Props {}

const {} = Astro.props;

import ChatWindow from "./ChatWindow.astro"; // <-- IMPORT ChatWindow
import { WEBLLM_CHAT_MODEL_ID } from "../siteConfig";

// Later, we might import the actual ChatWindow component
// import ChatWindow from './ChatWindow.astro';
---

<div id="expandable-chat-widget-container">
    <button
        id="chat-widget-toggle"
        aria-label="Toggle chat widget"
        aria-expanded="false"
    >
        <svg
            xmlns="http://www.w3.org/2000/svg"
            class="chat-icon"
            fill="none"
            viewBox="0 0 24 24"
            stroke="currentColor"
            stroke-width="2"
        >
            <path
                stroke-linecap="round"
                stroke-linejoin="round"
                d="M8 12h.01M12 12h.01M16 12h.01M21 12c0 5.523-4.477 10-10 10S1 17.523 1 12 5.477 2 11 2s10 4.477 10 10z"
            ></path>
        </svg>
    </button>

    <div id="chat-window-expanded" class="hidden">
        <ChatWindow />
    </div>
</div>

<script>
    // Client-side imports for the handlers and controller
    import { WebLLMHandler } from "../lib/webllmHandler";
    import { RAGController } from "../lib/ragController";
    import { WEBLLM_CHAT_MODEL_ID } from "../siteConfig"; // Client-side import for MODEL_ID
    // Import InitializationCallbacks for typing the onProgress callback's 'report' parameter
    import type { InitializationCallbacks } from "../lib/webllmHandler";
    // No need for separate type imports if runtime imports are used for types too

    let webllmHandler: WebLLMHandler | null = null;
    let ragController: RAGController | null = null;
    let servicesInitialized = false;

    // Variable to hold the chat window wrapper element, methods are attached to this in ChatWindow.astro
    let chatWindowInstance: HTMLElement | null = null;

    // TODO: This needs to be dynamically set based on user selection from the main page
    // For now, using a generic ID. This will be important for Vector RAG context.
    let currentDistrictId = "main_data"; // Or perhaps a more generic placeholder if not tied to a DB file name

    document.addEventListener("DOMContentLoaded", () => {
        const toggleButton = document.getElementById("chat-widget-toggle");
        const chatWindowContainer = document.getElementById(
            "chat-window-expanded",
        );
        // Assign to the globally scoped variable chatWindowInstance
        chatWindowInstance = chatWindowContainer?.querySelector(
            ".chat-window-internal-wrapper",
        ) as HTMLElement | null;

        const chatInputForFocus =
            chatWindowInstance?.querySelector("#chat-input");

        // Helper to show messages/status in the chat window
        // Updated to use chatWindowInstance
        function showChatWindowStatus(
            message: string,
            type = "system",
            replaceLast = false,
        ) {
            if (
                chatWindowInstance &&
                typeof (chatWindowInstance as any).addMessage === "function"
            ) {
                (chatWindowInstance as any).addMessage(
                    message,
                    type,
                    replaceLast,
                );
            } else {
                console.warn(
                    "ChatWindow.addMessage method not available to show status:",
                    message,
                );
            }
        }
        // Updated to use chatWindowInstance
        function enableChatInput(enable = true) {
            if (
                chatWindowInstance &&
                typeof (chatWindowInstance as any).enableInput === "function"
            ) {
                (chatWindowInstance as any).enableInput(enable);
            } else {
                console.warn(
                    `ChatWindow.enableInput method not available. Tried to set to ${enable}`,
                );
            }
        }

        // Renamed function to reflect initializing both services
        async function initializeRAGServices(): Promise<boolean> {
            if (servicesInitialized) return true;
            if (!chatWindowInstance) {
                console.error(
                    "Chat window instance not found during RAG initialization.",
                );
                return false;
            }

            // Single initial loading message, with replaceLast: true
            (chatWindowInstance as any).addMessage(
                "Initializing AI assistant, please wait...",
                "loading",
                true,
            );
            (chatWindowInstance as any).enableInput(false);

            try {
                // Initialize WebLLM Handler (progress will update the initial loading message)
                if (!webllmHandler) {
                    webllmHandler = new WebLLMHandler();
                }
                if (!webllmHandler.getIsInitialized()) {
                    // Initial "Initializing AI assistant..." message is still up or being updated by progress.
                    await webllmHandler.initialize(WEBLLM_CHAT_MODEL_ID, {
                        onProgress: (report) => {
                            (chatWindowInstance as any).addMessage(
                                `AI Assistant loading: ${report.text}`,
                                "loading",
                                true /* replaceLast */,
                            );
                        },
                    });
                    // No new message here, success message comes at the end.
                }

                // Initialize RAG Controller (silently)
                if (!ragController && webllmHandler) {
                    ragController = new RAGController(webllmHandler);
                } else if (!ragController) {
                    // This case implies webllmHandler was also not ready, which should be caught by earlier checks or throw.
                    // For robustness, ensure controller is available if webllmHandler is.
                    throw new Error(
                        "Failed to initialize RAGController: WebLLMHandler is required.",
                    );
                }

                servicesInitialized = true;
                // Final success messages
                (chatWindowInstance as any).addMessage(
                    "AI assistant is ready.",
                    "system",
                    true /* replaceLast: replaces the loading message */,
                );
                (chatWindowInstance as any).addMessage(
                    "How can I help you with district policies today?",
                    "ai", // This is the AI's first conversational bubble
                    false /* replaceLast: false, adds as a new message */,
                );
                (chatWindowInstance as any).enableInput(true);
                return true;
            } catch (error) {
                console.error("Error initializing RAG services:", error);
                const errorMessage =
                    error instanceof Error
                        ? error.message
                        : "Unknown error during service initialization.";
                // Error message replaces the loading message
                (chatWindowInstance as any).addMessage(
                    `Initialization Error: ${errorMessage}`,
                    "error",
                    true /* replaceLast */,
                );
                (chatWindowInstance as any).enableInput(false);
                return false;
            }
        }

        async function openChat() {
            if (
                chatWindowContainer &&
                toggleButton instanceof HTMLButtonElement
            ) {
                chatWindowContainer.classList.remove("hidden");
                toggleButton.setAttribute("aria-expanded", "true");

                // Use the renamed initialization function
                const success = await initializeRAGServices();

                if (
                    success &&
                    chatInputForFocus &&
                    chatInputForFocus instanceof HTMLElement
                ) {
                    chatInputForFocus.focus();
                } else if (!success) {
                    // Status already handled by initializeRAGServices
                }
            }
        }

        function closeChat() {
            if (
                chatWindowContainer &&
                toggleButton instanceof HTMLButtonElement
            ) {
                chatWindowContainer.classList.add("hidden");
                toggleButton.setAttribute("aria-expanded", "false");
                toggleButton.focus();
            }
        }

        if (toggleButton && chatWindowContainer) {
            toggleButton.addEventListener("click", () => {
                const isExpanded =
                    toggleButton.getAttribute("aria-expanded") === "true";
                if (isExpanded) {
                    closeChat();
                } else {
                    openChat();
                }
            });
        }

        // --- handleQueryRequest will later use ragController ---
        // Temporarily adapt to check RAG readiness
        async function handleQueryRequest(event: Event) {
            if (!(event instanceof CustomEvent) || !chatWindowInstance)
                // Use chatWindowInstance
                return;
            const query = event.detail?.query as string;

            if (typeof query !== "string") return;

            // Check if essential services and controller are ready
            if (
                !currentDistrictId || // Placeholder, will adapt for Vector RAG
                !webllmHandler ||
                !webllmHandler.getIsInitialized() || // Corrected check
                !ragController // Added null check for ragController
            ) {
                showChatWindowStatus(
                    "AI services not ready or controller missing. Please try reopening the chat.",
                    "error",
                );
                enableChatInput(true);
                return;
            }

            showChatWindowStatus("Processing your query...", "system");
            enableChatInput(false);

            try {
                // RAGController is checked for null above
                await ragController!.processQuery(
                    query,
                    currentDistrictId, // Pass currentDistrictId
                    (
                        message: string,
                        type: "ai" | "system" | "error" | "loading",
                        replaceLast = false,
                    ) => {
                        // If ChatWindow.astro's addMessage doesn't support replaceLast directly,
                        // we ensure that the call to it from here includes it.
                        // The previous implementation of addMessage in ChatWindow was:
                        // addMessage(content, type, id = undefined, replaceLastId = undefined)
                        // We might need to adjust ChatWindow if this new `replaceLast` boolean isn't directly compatible.
                        // For now, assuming chatWindowInstance.addMessage can take a boolean `replaceLast`.
                        (chatWindowInstance as any).addMessage(
                            message,
                            type,
                            replaceLast,
                        );
                    },
                );

                // No need to handle a return value from processQuery anymore.
                // const answer = await ragController.processQuery(...)
                // if (answer && !answer.startsWith("Sorry, I encountered an error")) { ... }
            } catch (error) {
                console.error(
                    "Error processing query with RAGController:",
                    error,
                );
                const errorMessage =
                    error instanceof Error
                        ? error.message
                        : "An unknown error occurred.";
                // Send this critical error via the chat window, replacing the last message (e.g., a loading message)
                (chatWindowInstance as any).addMessage(
                    `Error: ${errorMessage}`,
                    "error",
                    true,
                );
            } finally {
                (chatWindowInstance as any).enableInput(true); // Use chatWindowInstance
            }
        }

        if (chatWindowContainer) {
            console.log(
                "Adding listener for 'request-query-process' on #chat-window-expanded in ExpandableChatWidget.astro",
            );
            chatWindowContainer.addEventListener(
                "request-query-process",
                handleQueryRequest,
            );
        }
    });
</script>

<style>
    #expandable-chat-widget-container {
        position: fixed;
        bottom: 20px; /* Corresponds to bottom-5 */
        right: 20px; /* Corresponds to right-5 */
        z-index: 1000;
    }

    #chat-widget-toggle {
        background-color: var(--color-primary);
        color: var(--color-text-light);
        width: 60px; /* Increased size for better visibility */
        height: 60px;
        border-radius: 50%;
        border: none;
        box-shadow:
            0 10px 15px -3px rgba(0, 0, 0, 0.1),
            0 4px 6px -2px rgba(0, 0, 0, 0.05); /* shadow-xl */
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition:
            background-color 0.2s ease-in-out,
            transform 0.15s ease-in-out;
        animation: bounce-once-మిత్ర 1.2s ease-in-out 1s 1; /* Animation name, duration, timing, delay, iteration */
    }

    #chat-widget-toggle:hover {
        background-color: var(--color-primary-darker);
    }

    #chat-widget-toggle:focus {
        outline: 2px solid var(--color-primary);
        outline-offset: 2px;
    }

    .chat-icon {
        width: 32px; /* Corresponds to h-7 w-7 (approx 28px), slightly larger */
        height: 32px;
    }

    #chat-window-expanded {
        position: absolute;
        bottom: calc(100% + 1rem); /* 1rem above the button */
        right: 0;
        width: 320px; /* sm:w-96 is 384px, w-80 is 320px */
        height: 60vh; /* Consistent with Tailwind */
        max-height: 500px; /* Adjusted from 700px for typical chat widget */
        background-color: var(--color-text-light);
        border-radius: 0.5rem; /* rounded-lg */
        box-shadow:
            0 20px 25px -5px rgba(0, 0, 0, 0.1),
            0 10px 10px -5px rgba(0, 0, 0, 0.04); /* shadow-2xl */
        display: flex;
        flex-direction: column;
        overflow: hidden;
        border: 1px solid var(--color-border-light);
        /* Add initial state for transition (when hidden) */
        opacity: 0;
        visibility: hidden;
        transform: translateY(10px) scale(0.95);
        transform-origin: bottom right; /* Ensure scaling towards the button */
        transition:
            opacity 0.3s ease-in-out,
            transform 0.3s ease-in-out,
            visibility 0.3s ease-in-out; /* visibility transition ensures it's not interactive when hidden */
    }

    #chat-window-expanded:not(.hidden) {
        /* State when visible */
        opacity: 1;
        visibility: visible;
        transform: translateY(0) scale(1);
    }

    #chat-window-expanded.hidden {
        /* Keep hidden class for JS logic, but rely on opacity/visibility for transition */
        /* display: none; */ /* Replaced by opacity and visibility transitions */
    }

    @keyframes bounce-once-మిత్ర {
        0%,
        100% {
            transform: translateY(0);
        }
        50% {
            transform: translateY(-12px); /* Bounce height */
        }
    }
</style>
