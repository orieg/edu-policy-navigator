---
// src/components/ExpandableChatWidget.astro
// This component will manage the collapsed and expanded state of the chat widget.

// Props will be defined here later if needed, e.g., to pass district info or handlers.
interface Props {}

const {} = Astro.props;

import ChatWindow from "./ChatWindow.astro"; // <-- IMPORT ChatWindow
import { KuzuDBHandler } from "../lib/kuzudbHandler";
import { WebLLMHandler } from "../lib/webllmHandler";
import { RAGController } from "../lib/ragController";
import { MODEL_ID } from "../siteConfig";

// Mock function to simulate RAG processing
const mockProcessQueryFunction = async (query: string): Promise<string> => {
    console.log(`[Mock] Processing query: "${query}"`);
    return new Promise((resolve) => {
        setTimeout(() => {
            const response = `AI says: You asked about "${query}". This is a mock response.`;
            console.log(`[Mock] Responding with: "${response}"`);
            resolve(response);
        }, 1500);
    });
};

// Later, we might import the actual ChatWindow component
// import ChatWindow from './ChatWindow.astro';
---

<div id="expandable-chat-widget-container">
    <button
        id="chat-widget-toggle"
        aria-label="Toggle chat widget"
        aria-expanded="false"
    >
        <svg
            xmlns="http://www.w3.org/2000/svg"
            class="chat-icon"
            fill="none"
            viewBox="0 0 24 24"
            stroke="currentColor"
            stroke-width="2"
        >
            <path
                stroke-linecap="round"
                stroke-linejoin="round"
                d="M8 12h.01M12 12h.01M16 12h.01M21 12c0 5.523-4.477 10-10 10S1 17.523 1 12 5.477 2 11 2s10 4.477 10 10z"
            ></path>
        </svg>
    </button>

    <div id="chat-window-expanded" class="hidden">
        <ChatWindow />
    </div>
</div>

<script>
    let kuzuHandler: KuzuDBHandler | null = null;
    let webllmHandler: WebLLMHandler | null = null;
    let ragController: RAGController | null = null;
    let servicesInitialized = false;

    // TODO: This needs to be dynamically set based on user selection from the main page
    let currentDistrictId = "district_A"; // Placeholder

    // This manifest would ideally be fetched or passed as a prop
    const districtManifest = {
        district_A: { dbPath: "/placeholder_district_A.kuzu" },
        district_B: { dbPath: "/placeholder_district_B.kuzu" },
    };

    document.addEventListener("DOMContentLoaded", () => {
        const toggleButton = document.getElementById("chat-widget-toggle");
        const chatWindowContainer = document.getElementById(
            "chat-window-expanded",
        );
        const chatWindowInternalWrapper = chatWindowContainer?.querySelector(
            ".chat-window-internal-wrapper",
        );
        const chatInputForFocus =
            chatWindowInternalWrapper?.querySelector("#chat-input");

        // Helper to show messages/status in the chat window
        function showChatWindowStatus(message: string, type = "system") {
            if (
                chatWindowInternalWrapper &&
                typeof (chatWindowInternalWrapper as any).addMessage ===
                    "function"
            ) {
                (chatWindowInternalWrapper as any).addMessage(message, type);
            } else {
                console.warn(
                    "ChatWindow.addMessage method not available to show status:",
                    message,
                );
            }
        }
        function enableChatInput(enable = true) {
            if (
                chatWindowInternalWrapper &&
                typeof (chatWindowInternalWrapper as any).enableInput ===
                    "function"
            ) {
                (chatWindowInternalWrapper as any).enableInput(enable);
            } else {
                console.warn(
                    `ChatWindow.enableInput method not available. Tried to set to ${enable}`,
                );
            }
        }

        // Renamed function to reflect initializing both services
        async function initializeRAGServices() {
            if (servicesInitialized) return;

            chatWindowWrapper.addMessage(
                "Initializing RAG services...",
                "system",
            );
            chatWindowWrapper.enableInput(false);

            try {
                // Initialize KuzuDB Handler
                if (!kuzuHandler) {
                    kuzuHandler = new KuzuDBHandler();
                }
                if (!kuzuHandler.isInitialized()) {
                    chatWindowWrapper.addMessage(
                        "Initializing KuzuDB...",
                        "loading",
                    );
                    await kuzuHandler.initialize();
                    chatWindowWrapper.addMessage(
                        "KuzuDB Initialized.",
                        "system",
                    );
                } else {
                    chatWindowWrapper.addMessage(
                        "KuzuDB already initialized.",
                        "system",
                    );
                }

                // Initialize WebLLM Handler
                if (!webllmHandler) {
                    webllmHandler = new WebLLMHandler(MODEL_ID);
                }
                if (!webllmHandler.isInitialized()) {
                    chatWindowWrapper.addMessage(
                        "Initializing WebLLM... This may take a moment.",
                        "loading",
                    );
                    await webllmHandler.initialize((progress) => {
                        chatWindowWrapper.addMessage(
                            `WebLLM loading: ${progress.text}`,
                            "loading",
                            true /* replaceLast */,
                        );
                    });
                    chatWindowWrapper.addMessage(
                        "WebLLM Initialized.",
                        "system",
                        true,
                    );
                } else {
                    chatWindowWrapper.addMessage(
                        "WebLLM already initialized.",
                        "system",
                    );
                }

                // Initialize RAG Controller
                if (!ragController && kuzuHandler && webllmHandler) {
                    ragController = new RAGController(
                        kuzuHandler,
                        webllmHandler,
                    );
                    chatWindowWrapper.addMessage(
                        "RAG Controller Initialized.",
                        "system",
                    );
                } else if (ragController) {
                    chatWindowWrapper.addMessage(
                        "RAG Controller already initialized.",
                        "system",
                    );
                } else {
                    throw new Error(
                        "Failed to initialize RAGController: handlers not ready.",
                    );
                }

                servicesInitialized = true;
                chatWindowWrapper.addMessage(
                    "All RAG services ready.",
                    "system",
                );
                chatWindowWrapper.enableInput(true);
            } catch (error) {
                console.error("Error initializing RAG services:", error);
                const errorMessage =
                    error instanceof Error
                        ? error.message
                        : "Unknown error during service initialization.";
                chatWindowWrapper.addMessage(
                    `Initialization Error: ${errorMessage}`,
                    "error",
                );
                chatWindowWrapper.enableInput(false); // Keep input disabled if essential services fail
            }
        }

        async function openChat() {
            if (
                chatWindowContainer &&
                toggleButton instanceof HTMLButtonElement
            ) {
                chatWindowContainer.classList.remove("hidden");
                toggleButton.setAttribute("aria-expanded", "true");

                // Use the renamed initialization function
                const success = await initializeRAGServices();

                if (
                    success &&
                    chatInputForFocus &&
                    chatInputForFocus instanceof HTMLElement
                ) {
                    chatInputForFocus.focus();
                } else if (!success) {
                    // Status already handled by initializeRAGServices
                }
            }
        }

        function closeChat() {
            if (
                chatWindowContainer &&
                toggleButton instanceof HTMLButtonElement
            ) {
                chatWindowContainer.classList.add("hidden");
                toggleButton.setAttribute("aria-expanded", "false");
                toggleButton.focus();
            }
        }

        if (toggleButton && chatWindowContainer) {
            toggleButton.addEventListener("click", () => {
                const isExpanded =
                    toggleButton.getAttribute("aria-expanded") === "true";
                if (isExpanded) {
                    closeChat();
                } else {
                    openChat();
                }
            });
        }

        // --- handleQueryRequest will later use ragController ---
        // Temporarily adapt to check RAG readiness
        async function handleQueryRequest(event: Event) {
            if (!(event instanceof CustomEvent) || !chatWindowInternalWrapper)
                return;
            const query = event.detail?.query;

            if (typeof query !== "string") return;

            // Check if both services are ready for the current context
            if (
                !currentDistrictId ||
                !kuzuHandler ||
                !kuzuHandler.isInitialized() ||
                !webllmHandler ||
                !webllmHandler.isInitialized()
            ) {
                showChatWindowStatus(
                    "AI services not ready. Please try reopening the chat.",
                    "error",
                );
                enableChatInput(true);
                return;
            }

            showChatWindowStatus("Processing your query...", "system");
            enableChatInput(false);

            try {
                // RAGController's processQuery now returns void.
                // All messages, including the final answer or errors, are sent via the progressCallback.
                await ragController.processQuery(
                    query,
                    (message, type, replaceLast = false) => {
                        // If ChatWindow.astro's addMessage doesn't support replaceLast directly,
                        // we ensure that the call to it from here includes it.
                        // The previous implementation of addMessage in ChatWindow was:
                        // addMessage(content, type, id = undefined, replaceLastId = undefined)
                        // We might need to adjust ChatWindow if this new `replaceLast` boolean isn't directly compatible.
                        // For now, assuming chatWindowWrapper.addMessage can take a boolean `replaceLast`.
                        chatWindowInternalWrapper.addMessage(
                            message,
                            type,
                            replaceLast,
                        );
                    },
                );

                // No need to handle a return value from processQuery anymore.
                // const answer = await ragController.processQuery(...)
                // if (answer && !answer.startsWith("Sorry, I encountered an error")) { ... }
            } catch (error) {
                console.error(
                    "Error processing query with RAGController:",
                    error,
                );
                const errorMessage =
                    error instanceof Error
                        ? error.message
                        : "An unknown error occurred.";
                // Send this critical error via the chat window, replacing the last message (e.g., a loading message)
                chatWindowInternalWrapper.addMessage(
                    `Error: ${errorMessage}`,
                    "error",
                    true,
                );
            } finally {
                chatWindowInternalWrapper.enableInput(true);
            }
        }

        if (chatWindowContainer) {
            console.log(
                "Adding listener for 'request-query-process' on #chat-window-expanded in ExpandableChatWidget.astro",
            );
            chatWindowContainer.addEventListener(
                "request-query-process",
                handleQueryRequest,
            );
        }
    });
</script>

<style>
    #expandable-chat-widget-container {
        position: fixed;
        bottom: 20px; /* Corresponds to bottom-5 */
        right: 20px; /* Corresponds to right-5 */
        z-index: 1000;
    }

    #chat-widget-toggle {
        background-color: var(--color-primary);
        color: var(--color-text-light);
        width: 60px; /* Increased size for better visibility */
        height: 60px;
        border-radius: 50%;
        border: none;
        box-shadow:
            0 10px 15px -3px rgba(0, 0, 0, 0.1),
            0 4px 6px -2px rgba(0, 0, 0, 0.05); /* shadow-xl */
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition:
            background-color 0.2s ease-in-out,
            transform 0.15s ease-in-out;
        animation: bounce-once-మిత్ర 1.2s ease-in-out 1s 1; /* Animation name, duration, timing, delay, iteration */
    }

    #chat-widget-toggle:hover {
        background-color: var(--color-primary-darker);
    }

    #chat-widget-toggle:focus {
        outline: 2px solid var(--color-primary);
        outline-offset: 2px;
    }

    .chat-icon {
        width: 32px; /* Corresponds to h-7 w-7 (approx 28px), slightly larger */
        height: 32px;
    }

    #chat-window-expanded {
        position: absolute;
        bottom: calc(100% + 1rem); /* 1rem above the button */
        right: 0;
        width: 320px; /* sm:w-96 is 384px, w-80 is 320px */
        height: 60vh; /* Consistent with Tailwind */
        max-height: 500px; /* Adjusted from 700px for typical chat widget */
        background-color: var(--color-text-light);
        border-radius: 0.5rem; /* rounded-lg */
        box-shadow:
            0 20px 25px -5px rgba(0, 0, 0, 0.1),
            0 10px 10px -5px rgba(0, 0, 0, 0.04); /* shadow-2xl */
        display: flex;
        flex-direction: column;
        overflow: hidden;
        border: 1px solid var(--color-border-light);
        /* Add initial state for transition (when hidden) */
        opacity: 0;
        visibility: hidden;
        transform: translateY(10px) scale(0.95);
        transform-origin: bottom right; /* Ensure scaling towards the button */
        transition:
            opacity 0.3s ease-in-out,
            transform 0.3s ease-in-out,
            visibility 0.3s ease-in-out; /* visibility transition ensures it's not interactive when hidden */
    }

    #chat-window-expanded:not(.hidden) {
        /* State when visible */
        opacity: 1;
        visibility: visible;
        transform: translateY(0) scale(1);
    }

    #chat-window-expanded.hidden {
        /* Keep hidden class for JS logic, but rely on opacity/visibility for transition */
        /* display: none; */ /* Replaced by opacity and visibility transitions */
    }

    @keyframes bounce-once-మిత్ర {
        0%,
        100% {
            transform: translateY(0);
        }
        50% {
            transform: translateY(-12px); /* Bounce height */
        }
    }
</style>
